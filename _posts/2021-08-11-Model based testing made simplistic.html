---
layout: post
---
<p>Property based testing is an effective way to verify the input/output relation of pure functions,
leveraging predicates (properties) to declaratively describe such relation.</p>
<p><em>Model</em> based testing extends the scope to stateful systems,
whose behavior is described in terms of an abstract model,
leveraging the more operational paradigm of state machines.</p>
<p>This is an introduction aimed at providing a basic understanding of the idea.
It is yet another <a href="https://porg.es/model-based-testing/">poor man's approach</a>
which may also work in practice but, since it is deliberately simplistic,
you may also want to invest some time learning about the APIs
provided by <a href="https://fscheck.github.io/FsCheck//StatefulTestingNew.html">libraries</a>.</p>
<h2>A simple example</h2>
<p>Our system under test is the <code>Queue</code> class from the .NET base library.
We model its state as a list and we focus on two actions only: enqueue and dequeue.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">type</span> <span class="rt">Sut</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">System</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">Collections</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">Generic</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="id">Queue</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="vt">int</span><span class="pn">&gt;</span>

    <span class="k">type</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="rt">State</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="rt">list</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 8)" onmouseover="showTip(event, 'fs5', 8)" class="vt">int</span><span class="pn">&gt;</span>

    <span class="k">type</span> <span onmouseout="hideTip(event, 'fs8', 9)" onmouseover="showTip(event, 'fs8', 9)" class="rt">Action</span> <span class="o">=</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="uc">Enqueue</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fs5', 11)" onmouseover="showTip(event, 'fs5', 11)" class="vt">int</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="uc">Dequeue</span>
</code></pre></td>
</tr>
</table>
<p>The whole point of the approach is to execute an action both on the abstract model and on the actual system,
and then check that the resulting state is the same.</p>
<h3>The system and its model</h3>
<p>The functions <code>fromModel</code> and <code>toModel</code> define the correspondance between the abstract model and
the actual system. They are easy to implement in this example but may be challenging in more realistic scenarios.
Such challenges may be due to the system under test hiding its internal state or persisting it in a distributed
environment. Most libraries for model based testing in fact take a different route (as we will see later),
but for now we naively assume that:</p>
<ul>
<li><code>fromModel</code> puts the system under test in the given state.</li>
<li><code>toModel</code> retrieves the state of the system under test.</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs11', 13)" onmouseover="showTip(event, 'fs11', 13)" class="fn">fromModel</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 14)" onmouseover="showTip(event, 'fs12', 14)" class="fn">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 15)" onmouseover="showTip(event, 'fs6', 15)" class="rt">State</span><span class="pn">)</span> <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="fn">Sut</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 17)" onmouseover="showTip(event, 'fs12', 17)" class="fn">state</span><span class="pn">)</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 18)" onmouseover="showTip(event, 'fs14', 18)" class="fn">toModel</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 19)" onmouseover="showTip(event, 'fs15', 19)" class="fn">sut</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs13', 20)" onmouseover="showTip(event, 'fs13', 20)" class="rt">Sut</span><span class="pn">)</span> <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 22)" onmouseover="showTip(event, 'fs17', 22)" class="id">ofSeq</span> <span onmouseout="hideTip(event, 'fs15', 23)" onmouseover="showTip(event, 'fs15', 23)" class="fn">sut</span>
</code></pre></td>
</tr>
</table>
<h3>State transitions</h3>
<p>The essence of our model is captured by the following function defining state transitions:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 24)" onmouseover="showTip(event, 'fs18', 24)" class="fn">nextState</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 25)" onmouseover="showTip(event, 'fs12', 25)" class="fn">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 26)" onmouseover="showTip(event, 'fs6', 26)" class="rt">State</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 27)" onmouseover="showTip(event, 'fs19', 27)" class="fn">action</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 28)" onmouseover="showTip(event, 'fs8', 28)" class="rt">Action</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">match</span> <span onmouseout="hideTip(event, 'fs19', 29)" onmouseover="showTip(event, 'fs19', 29)" class="fn">action</span> <span class="k">with</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs9', 30)" onmouseover="showTip(event, 'fs9', 30)" class="uc">Enqueue</span> <span onmouseout="hideTip(event, 'fs20', 31)" onmouseover="showTip(event, 'fs20', 31)" class="fn">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs16', 32)" onmouseover="showTip(event, 'fs16', 32)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs21', 33)" onmouseover="showTip(event, 'fs21', 33)" class="id">append</span> <span onmouseout="hideTip(event, 'fs12', 34)" onmouseover="showTip(event, 'fs12', 34)" class="fn">state</span> <span class="pn">[</span><span onmouseout="hideTip(event, 'fs20', 35)" onmouseover="showTip(event, 'fs20', 35)" class="fn">x</span><span class="pn">]</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs10', 36)" onmouseover="showTip(event, 'fs10', 36)" class="uc">Dequeue</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 37)" onmouseover="showTip(event, 'fs12', 37)" class="fn">state</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 38)" onmouseover="showTip(event, 'fs22', 38)" class="id">Tail</span>
</code></pre></td>
</tr>
</table>
<p>The effect of enqueing an item corresponds (in the abstract model) to appending it to the
list representing the state of the system.</p>
<p>The abstract effect of a dequeue is to remove the head of the list representing the state.</p>
<p>The <code>run</code> function is the actual counterpart to the <code>nextState</code> function above.
This time the action is executed on the actual system under test.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 39)" onmouseover="showTip(event, 'fs23', 39)" class="fn">run</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 40)" onmouseover="showTip(event, 'fs15', 40)" class="fn">sut</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs13', 41)" onmouseover="showTip(event, 'fs13', 41)" class="rt">Sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 42)" onmouseover="showTip(event, 'fs19', 42)" class="fn">action</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 43)" onmouseover="showTip(event, 'fs8', 43)" class="rt">Action</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">match</span> <span onmouseout="hideTip(event, 'fs19', 44)" onmouseover="showTip(event, 'fs19', 44)" class="fn">action</span> <span class="k">with</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs9', 45)" onmouseover="showTip(event, 'fs9', 45)" class="uc">Enqueue</span> <span onmouseout="hideTip(event, 'fs20', 46)" onmouseover="showTip(event, 'fs20', 46)" class="fn">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs15', 47)" onmouseover="showTip(event, 'fs15', 47)" class="fn">sut</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs24', 48)" onmouseover="showTip(event, 'fs24', 48)" class="id">Enqueue</span> <span onmouseout="hideTip(event, 'fs20', 49)" onmouseover="showTip(event, 'fs20', 49)" class="fn">x</span>
        <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs10', 50)" onmouseover="showTip(event, 'fs10', 50)" class="uc">Dequeue</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs15', 51)" onmouseover="showTip(event, 'fs15', 51)" class="fn">sut</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs25', 52)" onmouseover="showTip(event, 'fs25', 52)" class="id">Dequeue</span><span class="pn">(</span><span class="pn">)</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 53)" onmouseover="showTip(event, 'fs26', 53)" class="fn">ignore</span>
        <span onmouseout="hideTip(event, 'fs14', 54)" onmouseover="showTip(event, 'fs14', 54)" class="fn">toModel</span> <span onmouseout="hideTip(event, 'fs15', 55)" onmouseover="showTip(event, 'fs15', 55)" class="fn">sut</span>
</code></pre></td>
</tr>
</table>
<h3>Invariant and Precondition</h3>
<p>Next we define two predicates: an invariant (that should hold in every state)
and a precondition (that should hold in order to perform an action):</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 56)" onmouseover="showTip(event, 'fs27', 56)" class="fn">invariant</span> <span class="pn">(</span><span class="id">_</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 57)" onmouseover="showTip(event, 'fs6', 57)" class="rt">State</span><span class="pn">)</span> <span class="o">=</span> <span class="k">true</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 58)" onmouseover="showTip(event, 'fs28', 58)" class="fn">precondition</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 59)" onmouseover="showTip(event, 'fs12', 59)" class="fn">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 60)" onmouseover="showTip(event, 'fs6', 60)" class="rt">State</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 61)" onmouseover="showTip(event, 'fs19', 61)" class="fn">action</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 62)" onmouseover="showTip(event, 'fs8', 62)" class="rt">Action</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">match</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 63)" onmouseover="showTip(event, 'fs12', 63)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 64)" onmouseover="showTip(event, 'fs19', 64)" class="fn">action</span><span class="pn">)</span> <span class="k">with</span>
        <span class="pn">|</span> <span class="pn">[</span><span class="pn">]</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs10', 65)" onmouseover="showTip(event, 'fs10', 65)" class="uc">Dequeue</span> <span class="k">-&gt;</span> <span class="k">false</span>
        <span class="pn">|</span> <span class="id">_</span> <span class="k">-&gt;</span> <span class="k">true</span>
</code></pre></td>
</tr>
</table>
<p>In this case the invariant always holds, we made illegal states unrepresentable! (but it was an easy win,
let me suggest a nice <a href="https://www.hillelwayne.com/post/constructive/">article</a> about this topic).</p>
<p>With the precondition we express that a dequeue action may not be performed on an empty queue.</p>
<h3>Running a test</h3>
<p>The <code>test</code> function initializes the system under test with the given state,
then runs the given action on it and finally checks that its resulting state
conforms to the model.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 66)" onmouseover="showTip(event, 'fs29', 66)" class="fn">test</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 67)" onmouseover="showTip(event, 'fs12', 67)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 68)" onmouseover="showTip(event, 'fs19', 68)" class="fn">action</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 69)" onmouseover="showTip(event, 'fs30', 69)" class="fn">check</span> <span onmouseout="hideTip(event, 'fs31', 70)" onmouseover="showTip(event, 'fs31', 70)" class="fn">error</span> <span onmouseout="hideTip(event, 'fs32', 71)" onmouseover="showTip(event, 'fs32', 71)" class="fn">x</span> <span class="o">=</span> <span class="k">if</span> <span onmouseout="hideTip(event, 'fs33', 72)" onmouseover="showTip(event, 'fs33', 72)" class="fn">not</span> <span onmouseout="hideTip(event, 'fs32', 73)" onmouseover="showTip(event, 'fs32', 73)" class="fn">x</span> <span class="k">then</span> <span onmouseout="hideTip(event, 'fs34', 74)" onmouseover="showTip(event, 'fs34', 74)" class="fn">failwith</span> <span onmouseout="hideTip(event, 'fs31', 75)" onmouseover="showTip(event, 'fs31', 75)" class="fn">error</span>

        <span onmouseout="hideTip(event, 'fs27', 76)" onmouseover="showTip(event, 'fs27', 76)" class="fn">invariant</span> <span onmouseout="hideTip(event, 'fs12', 77)" onmouseover="showTip(event, 'fs12', 77)" class="fn">state</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 78)" onmouseover="showTip(event, 'fs30', 78)" class="fn">check</span> <span class="s">&quot;Input Invariant&quot;</span>

        <span onmouseout="hideTip(event, 'fs28', 79)" onmouseover="showTip(event, 'fs28', 79)" class="fn">precondition</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 80)" onmouseover="showTip(event, 'fs12', 80)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 81)" onmouseover="showTip(event, 'fs19', 81)" class="fn">action</span><span class="pn">)</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 82)" onmouseover="showTip(event, 'fs30', 82)" class="fn">check</span> <span class="s">&quot;Precondition&quot;</span>

        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 83)" onmouseover="showTip(event, 'fs15', 83)" class="fn">sut</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs11', 84)" onmouseover="showTip(event, 'fs11', 84)" class="fn">fromModel</span> <span onmouseout="hideTip(event, 'fs12', 85)" onmouseover="showTip(event, 'fs12', 85)" class="fn">state</span>

        <span onmouseout="hideTip(event, 'fs14', 86)" onmouseover="showTip(event, 'fs14', 86)" class="fn">toModel</span> <span onmouseout="hideTip(event, 'fs15', 87)" onmouseover="showTip(event, 'fs15', 87)" class="fn">sut</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs12', 88)" onmouseover="showTip(event, 'fs12', 88)" class="fn">state</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 89)" onmouseover="showTip(event, 'fs30', 89)" class="fn">check</span> <span class="s">&quot;Initial State&quot;</span>

        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 90)" onmouseover="showTip(event, 'fs35', 90)" class="fn">expected</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs18', 91)" onmouseover="showTip(event, 'fs18', 91)" class="fn">nextState</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 92)" onmouseover="showTip(event, 'fs12', 92)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 93)" onmouseover="showTip(event, 'fs19', 93)" class="fn">action</span><span class="pn">)</span>

        <span onmouseout="hideTip(event, 'fs27', 94)" onmouseover="showTip(event, 'fs27', 94)" class="fn">invariant</span> <span onmouseout="hideTip(event, 'fs35', 95)" onmouseover="showTip(event, 'fs35', 95)" class="fn">expected</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 96)" onmouseover="showTip(event, 'fs30', 96)" class="fn">check</span> <span class="s">&quot;Expected Invariant&quot;</span>

        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs36', 97)" onmouseover="showTip(event, 'fs36', 97)" class="fn">actual</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 98)" onmouseover="showTip(event, 'fs23', 98)" class="fn">run</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 99)" onmouseover="showTip(event, 'fs15', 99)" class="fn">sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 100)" onmouseover="showTip(event, 'fs19', 100)" class="fn">action</span><span class="pn">)</span>

        <span onmouseout="hideTip(event, 'fs36', 101)" onmouseover="showTip(event, 'fs36', 101)" class="fn">actual</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 102)" onmouseover="showTip(event, 'fs35', 102)" class="fn">expected</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 103)" onmouseover="showTip(event, 'fs30', 103)" class="fn">check</span> <span class="s">&quot;Final State&quot;</span>
</code></pre></td>
</tr>
</table>
<p>Let's examine the code in more detail.</p>
<p>First we check that the input satisfies the invariant and the precondition.</p>
<p>Then we initialize the system under test, establishing the given state
(and we verify that the initialization succeded by checking the state).</p>
<p>Next we use the model to get the state expected after the execution of the action
(and we verify that this next state produced by the model still satisfies the invariant).</p>
<p>Then we run the action on the actual system, and we verify that, after the execution,
the state of the system under test is the same as the expected one according to the model.</p>
<h3>Random input</h3>
<p>To run <code>test</code> with many random inputs we need a generator of state-action pairs satisfying invariant and precondition.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="pp">#r</span> <span class="s">&quot;nuget: FsCheck&quot;</span>

    <span class="k">open</span> <span onmouseout="hideTip(event, 'fs37', 104)" onmouseover="showTip(event, 'fs37', 104)" class="id">FsCheck</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 105)" onmouseover="showTip(event, 'fs38', 105)" class="fn">actionGenerator</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 106)" onmouseover="showTip(event, 'fs12', 106)" class="fn">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 107)" onmouseover="showTip(event, 'fs6', 107)" class="rt">State</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs39', 108)" onmouseover="showTip(event, 'fs39', 108)" class="fn">enq</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs40', 109)" onmouseover="showTip(event, 'fs40', 109)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs41', 110)" onmouseover="showTip(event, 'fs41', 110)" class="id">map</span> <span onmouseout="hideTip(event, 'fs9', 111)" onmouseover="showTip(event, 'fs9', 111)" class="uc">Enqueue</span> <span onmouseout="hideTip(event, 'fs42', 112)" onmouseover="showTip(event, 'fs42', 112)" class="m">Arb</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs43', 113)" onmouseover="showTip(event, 'fs43', 113)" class="id">generate</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 114)" onmouseover="showTip(event, 'fs5', 114)" class="vt">int</span><span class="pn">&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs44', 115)" onmouseover="showTip(event, 'fs44', 115)" class="fn">deq</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs40', 116)" onmouseover="showTip(event, 'fs40', 116)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs45', 117)" onmouseover="showTip(event, 'fs45', 117)" class="id">constant</span> <span onmouseout="hideTip(event, 'fs10', 118)" onmouseover="showTip(event, 'fs10', 118)" class="uc">Dequeue</span>
        <span class="k">if</span> <span onmouseout="hideTip(event, 'fs12', 119)" onmouseover="showTip(event, 'fs12', 119)" class="fn">state</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs46', 120)" onmouseover="showTip(event, 'fs46', 120)" class="id">IsEmpty</span>
        <span class="k">then</span> <span onmouseout="hideTip(event, 'fs39', 121)" onmouseover="showTip(event, 'fs39', 121)" class="fn">enq</span>
        <span class="k">else</span> <span onmouseout="hideTip(event, 'fs40', 122)" onmouseover="showTip(event, 'fs40', 122)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs47', 123)" onmouseover="showTip(event, 'fs47', 123)" class="id">oneof</span> <span class="pn">[</span><span onmouseout="hideTip(event, 'fs39', 124)" onmouseover="showTip(event, 'fs39', 124)" class="fn">enq</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs44', 125)" onmouseover="showTip(event, 'fs44', 125)" class="fn">deq</span><span class="pn">]</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 126)" onmouseover="showTip(event, 'fs48', 126)" class="id">arbitraryStep</span> <span class="o">=</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs49', 127)" onmouseover="showTip(event, 'fs49', 127)" class="fn">stepGenerator</span> <span class="o">=</span>
            <span onmouseout="hideTip(event, 'fs50', 128)" onmouseover="showTip(event, 'fs50', 128)" class="k">gen</span> <span class="pn">{</span>
                <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs51', 129)" onmouseover="showTip(event, 'fs51', 129)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs40', 130)" onmouseover="showTip(event, 'fs40', 130)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs52', 131)" onmouseover="showTip(event, 'fs52', 131)" class="id">listOf</span> <span onmouseout="hideTip(event, 'fs42', 132)" onmouseover="showTip(event, 'fs42', 132)" class="m">Arb</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs43', 133)" onmouseover="showTip(event, 'fs43', 133)" class="id">generate</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 134)" onmouseover="showTip(event, 'fs5', 134)" class="vt">int</span><span class="pn">&gt;</span>
                <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs19', 135)" onmouseover="showTip(event, 'fs19', 135)" class="fn">action</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs38', 136)" onmouseover="showTip(event, 'fs38', 136)" class="fn">actionGenerator</span> <span onmouseout="hideTip(event, 'fs51', 137)" onmouseover="showTip(event, 'fs51', 137)" class="fn">state</span>
                <span class="k">return</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs51', 138)" onmouseover="showTip(event, 'fs51', 138)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 139)" onmouseover="showTip(event, 'fs19', 139)" class="fn">action</span><span class="pn">)</span>
            <span class="pn">}</span>
        <span onmouseout="hideTip(event, 'fs42', 140)" onmouseover="showTip(event, 'fs42', 140)" class="m">Arb</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs53', 141)" onmouseover="showTip(event, 'fs53', 141)" class="id">fromGen</span> <span onmouseout="hideTip(event, 'fs49', 142)" onmouseover="showTip(event, 'fs49', 142)" class="fn">stepGenerator</span>

    <span onmouseout="hideTip(event, 'fs54', 143)" onmouseover="showTip(event, 'fs54', 143)" class="m">Prop</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs55', 144)" onmouseover="showTip(event, 'fs55', 144)" class="id">forAll</span> <span onmouseout="hideTip(event, 'fs48', 145)" onmouseover="showTip(event, 'fs48', 145)" class="id">arbitraryStep</span> <span onmouseout="hideTip(event, 'fs29', 146)" onmouseover="showTip(event, 'fs29', 146)" class="fn">test</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs56', 147)" onmouseover="showTip(event, 'fs56', 147)" class="rt">Check</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs57', 148)" onmouseover="showTip(event, 'fs57', 148)" class="id">Quick</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>Ok, passed 100 tests.</code></pre></td></tr></table>
<h2>FsCheck state machines</h2>
<p>As anticipated, initializing a real system to an arbitrary state may be hard.
But we can explore many states executing a <em>sequence</em> of actions starting from a state that's easy to establish.</p>
<p>FsCheck state machines allow this. It requires a bit of boilerplate,
but we can reuse <code>actionGenerator</code>, <code>nextState</code> and <code>run</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">    <span class="k">open</span> <span onmouseout="hideTip(event, 'fs37', 149)" onmouseover="showTip(event, 'fs37', 149)" class="id">FsCheck</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs58', 150)" onmouseover="showTip(event, 'fs58', 150)" class="id">Experimental</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs59', 151)" onmouseover="showTip(event, 'fs59', 151)" class="id">machine</span> <span class="o">=</span> <span class="pn">{</span>
        <span class="k">new</span> <span onmouseout="hideTip(event, 'fs60', 152)" onmouseover="showTip(event, 'fs60', 152)" class="rt">Machine</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs13', 153)" onmouseover="showTip(event, 'fs13', 153)" class="rt">Sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs6', 154)" onmouseover="showTip(event, 'fs6', 154)" class="rt">State</span><span class="pn">&gt;</span><span class="pn">(</span><span class="pn">)</span> <span class="k">with</span>
            <span class="k">member</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Setup</span> <span class="o">=</span>
                <span class="pn">{</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs61', 155)" onmouseover="showTip(event, 'fs61', 155)" class="rt">Setup</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs13', 156)" onmouseover="showTip(event, 'fs13', 156)" class="rt">Sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs6', 157)" onmouseover="showTip(event, 'fs6', 157)" class="rt">State</span><span class="pn">&gt;</span><span class="pn">(</span><span class="pn">)</span> <span class="k">with</span>
                    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs62', 158)" onmouseover="showTip(event, 'fs62', 158)" class="id">__</span><span class="pn">.</span><span class="fn">Actual</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs13', 159)" onmouseover="showTip(event, 'fs13', 159)" class="fn">Sut</span><span class="pn">(</span><span class="pn">)</span>
                    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs63', 160)" onmouseover="showTip(event, 'fs63', 160)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs64', 161)" onmouseover="showTip(event, 'fs64', 161)" class="fn">Model</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span class="pn">[</span><span class="pn">]</span> <span class="pn">}</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 162)" onmouseover="showTip(event, 'fs40', 162)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs45', 163)" onmouseover="showTip(event, 'fs45', 163)" class="id">constant</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs42', 164)" onmouseover="showTip(event, 'fs42', 164)" class="m">Arb</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs53', 165)" onmouseover="showTip(event, 'fs53', 165)" class="id">fromGen</span>

            <span class="k">member</span> <span onmouseout="hideTip(event, 'fs62', 166)" onmouseover="showTip(event, 'fs62', 166)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs65', 167)" onmouseover="showTip(event, 'fs65', 167)" class="fn">Next</span> <span onmouseout="hideTip(event, 'fs12', 168)" onmouseover="showTip(event, 'fs12', 168)" class="fn">state</span> <span class="o">=</span>
                <span onmouseout="hideTip(event, 'fs38', 169)" onmouseover="showTip(event, 'fs38', 169)" class="fn">actionGenerator</span> <span onmouseout="hideTip(event, 'fs12', 170)" onmouseover="showTip(event, 'fs12', 170)" class="fn">state</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 171)" onmouseover="showTip(event, 'fs40', 171)" class="m">Gen</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs41', 172)" onmouseover="showTip(event, 'fs41', 172)" class="id">map</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs19', 173)" onmouseover="showTip(event, 'fs19', 173)" class="fn">action</span> <span class="k">-&gt;</span> <span class="pn">{</span>
                    <span class="k">new</span> <span onmouseout="hideTip(event, 'fs66', 174)" onmouseover="showTip(event, 'fs66', 174)" class="rt">Operation</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs13', 175)" onmouseover="showTip(event, 'fs13', 175)" class="rt">Sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs6', 176)" onmouseover="showTip(event, 'fs6', 176)" class="rt">State</span><span class="pn">&gt;</span><span class="pn">(</span><span class="pn">)</span> <span class="k">with</span>
                        <span class="k">member</span> <span onmouseout="hideTip(event, 'fs62', 177)" onmouseover="showTip(event, 'fs62', 177)" class="id">__</span><span class="pn">.</span><span class="fn">Run</span> <span onmouseout="hideTip(event, 'fs12', 178)" onmouseover="showTip(event, 'fs12', 178)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs18', 179)" onmouseover="showTip(event, 'fs18', 179)" class="fn">nextState</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 180)" onmouseover="showTip(event, 'fs12', 180)" class="fn">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 181)" onmouseover="showTip(event, 'fs19', 181)" class="fn">action</span><span class="pn">)</span>

                        <span class="k">member</span> <span onmouseout="hideTip(event, 'fs67', 182)" onmouseover="showTip(event, 'fs67', 182)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs68', 183)" onmouseover="showTip(event, 'fs68', 183)" class="fn">Check</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 184)" onmouseover="showTip(event, 'fs15', 184)" class="fn">sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs12', 185)" onmouseover="showTip(event, 'fs12', 185)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span>
                            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs36', 186)" onmouseover="showTip(event, 'fs36', 186)" class="fn">actual</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 187)" onmouseover="showTip(event, 'fs23', 187)" class="fn">run</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 188)" onmouseover="showTip(event, 'fs15', 188)" class="fn">sut</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs19', 189)" onmouseover="showTip(event, 'fs19', 189)" class="fn">action</span><span class="pn">)</span>
                            <span onmouseout="hideTip(event, 'fs12', 190)" onmouseover="showTip(event, 'fs12', 190)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs36', 191)" onmouseover="showTip(event, 'fs36', 191)" class="fn">actual</span>
                            <span class="o">|@</span> <span onmouseout="hideTip(event, 'fs69', 192)" onmouseover="showTip(event, 'fs69', 192)" class="fn">sprintf</span> <span class="s">&quot;Inc: model = </span><span class="pf">%A</span><span class="s">, actual = </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs12', 193)" onmouseover="showTip(event, 'fs12', 193)" class="fn">state</span> <span onmouseout="hideTip(event, 'fs36', 194)" onmouseover="showTip(event, 'fs36', 194)" class="fn">actual</span>

                        <span class="k">override</span> <span onmouseout="hideTip(event, 'fs67', 195)" onmouseover="showTip(event, 'fs67', 195)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs70', 196)" onmouseover="showTip(event, 'fs70', 196)" class="fn">ToString</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs69', 197)" onmouseover="showTip(event, 'fs69', 197)" class="fn">sprintf</span> <span class="s">&quot;</span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs19', 198)" onmouseover="showTip(event, 'fs19', 198)" class="fn">action</span> <span class="pn">}</span><span class="pn">)</span>
    <span class="pn">}</span>

    <span onmouseout="hideTip(event, 'fs71', 199)" onmouseover="showTip(event, 'fs71', 199)" class="m">StateMachine</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs72', 200)" onmouseover="showTip(event, 'fs72', 200)" class="id">toProperty</span> <span onmouseout="hideTip(event, 'fs59', 201)" onmouseover="showTip(event, 'fs59', 201)" class="id">machine</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs56', 202)" onmouseover="showTip(event, 'fs56', 202)" class="rt">Check</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs57', 203)" onmouseover="showTip(event, 'fs57', 203)" class="id">Quick</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>Ok, passed 100 tests.
95% long sequences (&gt;6 commands).
5% short sequences (between 1-6 commands).</code></pre></td></tr></table>
<p>Among the benefits of using a real library, we get shrinking and useful error messages in
case of test failures.
Notice also the added flexibility given by the <code>Check</code> method: if the state is hard to retrieve,
instead of calling <code>run</code> and checking the whole state, we are free to focus only on the relevant part of the system.</p>
<h2>Understanding vs verifying</h2>
<p>Instead of discussing how effective the approach is for verification,
let me point out that modeling is valuable at least to document a system
and to better understand it: the <code>nextState</code> function expresses our understanding of the system.</p>
<p>If you're familiar with the <a href="https://zaid-ajaj.github.io/the-elmish-book/#/">ELM Architecture</a>,
looking at <code>nextState</code> should ring a bell: just add a view function and you have the MVU pattern!</p>
<p>And F# allows to use the same code both for verification with .NET
and for visualization with JavaScript.</p>
<p>I think this is an aspect worth exploring, in the spirit of Saymour Papert.</p>
<h2>Final remark on abstraction</h2>
<p>The provided example was not meant to precisely capture the essence of the queue concept.
It may be improved and refined to this aim, but I just wanted to describe a small stateful system.</p>
<p>I often praise abstract data types but, quoting Leslie Lamport
(via <a href="https://pron.github.io/posts/tlaplus_part4#model-based-specifications-and-information-hiding">Ron Pressler</a>):</p>
<blockquote>
<p>The lesson I learned from the specification work of the early ’80s is that axiomatic specifications don’t work.
The idea of specifying a system by writing down all the properties it satisfies seems perfect.
We just list what the system must and must not do, and we have a completely abstract specification.
It sounds wonderful; it just doesn’t work in practice.</p>
</blockquote>
<p>I have to admit we rarely encounter formal ADT specifications
besides <a href="https://bertrandmeyer.com/2019/12/03/are-my-requirements-complete/">simple examples</a>
and <a href="https://giacomociti.github.io/2018/05/26/The-lost-art-of-data-abstraction.html">stacks</a>
(a quip of Djikstra, according to Bertrand Meyer, is that the purpose of ADT theory is to define stacks).</p>
<p>So, if we leave aside <a href="https://plato.stanford.edu/archives/spr2016/entries/computer-science/">philosophy</a>,
we can lower a bit the pretenses of full abstraction and understand our systems better,
adopting the operational paradigm of state machines.</p>


<div class="fsdocs-tip" id="fs1">namespace System</div>
<div class="fsdocs-tip" id="fs2">namespace System.Collections</div>
<div class="fsdocs-tip" id="fs3">namespace System.Collections.Generic</div>
<div class="fsdocs-tip" id="fs4">Multiple items<br />type Queue&lt;&#39;T&gt; =
  interface IEnumerable&lt;&#39;T&gt;
  interface IEnumerable
  interface IReadOnlyCollection&lt;&#39;T&gt;
  interface ICollection
  new : unit -&gt; unit + 2 overloads
  member Clear : unit -&gt; unit
  member Contains : item: &#39;T -&gt; bool
  member CopyTo : array: &#39;T [] * arrayIndex: int -&gt; unit
  member Dequeue : unit -&gt; &#39;T
  member Enqueue : item: &#39;T -&gt; unit
  ...<br /><em>&lt;summary&gt;Represents a first-in, first-out collection of objects.&lt;/summary&gt;<br />&lt;typeparam name=&quot;T&quot;&gt;Specifies the type of elements in the queue.&lt;/typeparam&gt;</em><br /><br />--------------------<br />System.Collections.Generic.Queue() : System.Collections.Generic.Queue&lt;&#39;T&gt;<br />System.Collections.Generic.Queue(collection: System.Collections.Generic.IEnumerable&lt;&#39;T&gt;) : System.Collections.Generic.Queue&lt;&#39;T&gt;<br />System.Collections.Generic.Queue(capacity: int) : System.Collections.Generic.Queue&lt;&#39;T&gt;</div>
<div class="fsdocs-tip" id="fs5">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><em>&lt;summary&gt;Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The input value.&lt;/param&gt;<br />&lt;returns&gt;The converted int&lt;/returns&gt;</em><br /><br />--------------------<br />[&lt;Struct&gt;]
type int = int32<br /><em>&lt;summary&gt;An abbreviation for the CLI type &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types&lt;/category&gt;</em><br /><br />--------------------<br />type int&lt;&#39;Measure&gt; =
  int<br /><em>&lt;summary&gt;The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;see cref=&quot;T:System.Int32&quot; /&gt;.&lt;/summary&gt;<br />&lt;category&gt;Basic Types with Units of Measure&lt;/category&gt;</em></div>
<div class="fsdocs-tip" id="fs6">type State = int list</div>
<div class="fsdocs-tip" id="fs7">type &#39;T list = List&lt;&#39;T&gt;<br /><em>&lt;summary&gt;The type of immutable singly-linked lists. &lt;/summary&gt;<br />&lt;remarks&gt;See the &lt;see cref=&quot;T:Microsoft.FSharp.Collections.ListModule&quot; /&gt; module for further operations related to lists.

 Use the constructors &lt;c&gt;[]&lt;/c&gt; and &lt;c&gt;::&lt;/c&gt; (infix) to create values of this type, or
 the notation &lt;c&gt;[1; 2; 3]&lt;/c&gt;. Use the values in the &lt;c&gt;List&lt;/c&gt; module to manipulate 
 values of this type, or pattern match against the values directly.

  See also &lt;a href=&quot;https://docs.microsoft.com/dotnet/fsharp/language-reference/lists&quot;&gt;F# Language Guide - Lists&lt;/a&gt;.
 &lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs8">type Action =
  | Enqueue of int
  | Dequeue</div>
<div class="fsdocs-tip" id="fs9">union case Action.Enqueue: int -&gt; Action</div>
<div class="fsdocs-tip" id="fs10">union case Action.Dequeue: Action</div>
<div class="fsdocs-tip" id="fs11">val fromModel : state:State -&gt; Sut</div>
<div class="fsdocs-tip" id="fs12">val state : State</div>
<div class="fsdocs-tip" id="fs13">type Sut = System.Collections.Generic.Queue&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs14">val toModel : sut:Sut -&gt; int list</div>
<div class="fsdocs-tip" id="fs15">val sut : Sut</div>
<div class="fsdocs-tip" id="fs16">Multiple items<br />module List

from Microsoft.FSharp.Collections<br /><em>&lt;summary&gt;Contains operations for working with values of type &lt;see cref=&quot;T:Microsoft.FSharp.Collections.list`1&quot; /&gt;.&lt;/summary&gt;<br />&lt;namespacedoc&gt;&lt;summary&gt;Operations for collections such as lists, arrays, sets, maps and sequences. See also 
    &lt;a href=&quot;https://docs.microsoft.com/dotnet/fsharp/language-reference/fsharp-collection-types&quot;&gt;F# Collection Types&lt;/a&gt; in the F# Language Guide.
 &lt;/summary&gt;&lt;/namespacedoc&gt;</em><br /><br />--------------------<br />type List&lt;&#39;T&gt; =
  | ( [] )
  | ( :: ) of Head: &#39;T * Tail: &#39;T list
    interface IReadOnlyList&lt;&#39;T&gt;
    interface IReadOnlyCollection&lt;&#39;T&gt;
    interface IEnumerable
    interface IEnumerable&lt;&#39;T&gt;
    member GetReverseIndex : rank:int * offset:int -&gt; int
    member GetSlice : startIndex:int option * endIndex:int option -&gt; &#39;T list
    static member Cons : head:&#39;T * tail:&#39;T list -&gt; &#39;T list
    member Head : &#39;T
    member IsEmpty : bool
    member Item : index:int -&gt; &#39;T with get
    ...<br /><em>&lt;summary&gt;The type of immutable singly-linked lists.&lt;/summary&gt;<br />&lt;remarks&gt;Use the constructors &lt;c&gt;[]&lt;/c&gt; and &lt;c&gt;::&lt;/c&gt; (infix) to create values of this type, or
 the notation &lt;c&gt;[1;2;3]&lt;/c&gt;. Use the values in the &lt;c&gt;List&lt;/c&gt; module to manipulate 
 values of this type, or pattern match against the values directly.
 &lt;/remarks&gt;<br />&lt;exclude /&gt;</em></div>
<div class="fsdocs-tip" id="fs17">val ofSeq : source:seq&lt;&#39;T&gt; -&gt; &#39;T list<br /><em>&lt;summary&gt;Builds a new list from the given enumerable object.&lt;/summary&gt;<br />&lt;param name=&quot;source&quot;&gt;The input sequence.&lt;/param&gt;<br />&lt;returns&gt;The list of elements from the sequence.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs18">val nextState : state:State * action:Action -&gt; int list</div>
<div class="fsdocs-tip" id="fs19">val action : Action</div>
<div class="fsdocs-tip" id="fs20">val x : int</div>
<div class="fsdocs-tip" id="fs21">val append : list1:&#39;T list -&gt; list2:&#39;T list -&gt; &#39;T list<br /><em>&lt;summary&gt;Returns a new list that contains the elements of the first list
 followed by elements of the second.&lt;/summary&gt;<br />&lt;param name=&quot;list1&quot;&gt;The first input list.&lt;/param&gt;<br />&lt;param name=&quot;list2&quot;&gt;The second input list.&lt;/param&gt;<br />&lt;returns&gt;The resulting list.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs22">property List.Tail: int list with get<br /><em>&lt;summary&gt;Gets the tail of the list, which is a list containing all the elements of the list, excluding the first element &lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs23">val run : sut:Sut * action:Action -&gt; int list</div>
<div class="fsdocs-tip" id="fs24">System.Collections.Generic.Queue.Enqueue(item: int) : unit</div>
<div class="fsdocs-tip" id="fs25">System.Collections.Generic.Queue.Dequeue() : int</div>
<div class="fsdocs-tip" id="fs26">val ignore : value:&#39;T -&gt; unit<br /><em>&lt;summary&gt;Ignore the passed value. This is often used to throw away results of a computation.&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The value to ignore.&lt;/param&gt;</em></div>
<div class="fsdocs-tip" id="fs27">val invariant : State -&gt; bool</div>
<div class="fsdocs-tip" id="fs28">val precondition : state:State * action:Action -&gt; bool</div>
<div class="fsdocs-tip" id="fs29">val test : state:State * action:Action -&gt; unit</div>
<div class="fsdocs-tip" id="fs30">val check : (string -&gt; bool -&gt; unit)</div>
<div class="fsdocs-tip" id="fs31">val error : string</div>
<div class="fsdocs-tip" id="fs32">val x : bool</div>
<div class="fsdocs-tip" id="fs33">val not : value:bool -&gt; bool<br /><em>&lt;summary&gt;Negate a logical value. Not True equals False and not False equals True&lt;/summary&gt;<br />&lt;param name=&quot;value&quot;&gt;The value to negate.&lt;/param&gt;<br />&lt;returns&gt;The result of the negation.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs34">val failwith : message:string -&gt; &#39;T<br /><em>&lt;summary&gt;Throw a &lt;see cref=&quot;T:System.Exception&quot; /&gt; exception.&lt;/summary&gt;<br />&lt;param name=&quot;message&quot;&gt;The exception message.&lt;/param&gt;<br />&lt;returns&gt;The result value.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs35">val expected : int list</div>
<div class="fsdocs-tip" id="fs36">val actual : int list</div>
<div class="fsdocs-tip" id="fs37">namespace FsCheck</div>
<div class="fsdocs-tip" id="fs38">val actionGenerator : state:State -&gt; Gen&lt;Action&gt;</div>
<div class="fsdocs-tip" id="fs39">val enq : Gen&lt;Action&gt;</div>
<div class="fsdocs-tip" id="fs40">Multiple items<br />module Gen

from FsCheck<br /><em>&lt;summary&gt;
Combinators to build custom random generators for any type.
&lt;/summary&gt;</em><br /><br />--------------------<br />type Gen&lt;&#39;a&gt; =
  private | Gen of (int -&gt; StdGen -&gt; &#39;a)
    interface IGen
    member private Map : f:(&#39;a -&gt; &#39;b) -&gt; Gen&lt;&#39;b&gt;
    static member ( &lt;!&gt; ) : f:(&#39;a1 -&gt; &#39;a2) * a:Gen&lt;&#39;a1&gt; -&gt; Gen&lt;&#39;a2&gt;
    static member ( &lt;*&gt; ) : f:Gen&lt;(&#39;a1 -&gt; &#39;a2)&gt; * a:Gen&lt;&#39;a1&gt; -&gt; Gen&lt;&#39;a2&gt;
    static member ( &gt;&gt;= ) : m:Gen&lt;&#39;a1&gt; * k:(&#39;a1 -&gt; Gen&lt;&#39;a2&gt;) -&gt; Gen&lt;&#39;a2&gt;<br /><em>&lt;summary&gt;
Generator of a random value, based on a size parameter and a randomly generated int.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs41">val map : f:(&#39;b -&gt; &#39;c) -&gt; gen:Gen&lt;&#39;b&gt; -&gt; Gen&lt;&#39;c&gt;<br /><em>&lt;summary&gt;
Apply the function f to the value in the generator, yielding a new generator.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs42">module Arb

from FsCheck</div>
<div class="fsdocs-tip" id="fs43">val generate&lt;&#39;Value&gt; : Gen&lt;&#39;Value&gt;<br /><em>&lt;summary&gt;
Returns a Gen&amp;lt;&#39;Value&amp;gt;
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs44">val deq : Gen&lt;Action&gt;</div>
<div class="fsdocs-tip" id="fs45">val constant : v:&#39;b -&gt; Gen&lt;&#39;b&gt;<br /><em>&lt;summary&gt;
Always generate the same instance v. See also fresh.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs46">property List.IsEmpty: bool with get<br /><em>&lt;summary&gt;Gets a value indicating if the list contains no entries&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs47">val oneof : gens:seq&lt;Gen&lt;&#39;a&gt;&gt; -&gt; Gen&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
Build a generator that generates a value from one of the generators in the given non-empty seq, with
equal probability.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs48">val arbitraryStep : Arbitrary&lt;int list * Action&gt;</div>
<div class="fsdocs-tip" id="fs49">val stepGenerator : Gen&lt;int list * Action&gt;</div>
<div class="fsdocs-tip" id="fs50">val gen : GenBuilder<br /><em>&lt;summary&gt;
The workflow function for generators, e.g. gen { ... }
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs51">val state : int list</div>
<div class="fsdocs-tip" id="fs52">val listOf : gn:Gen&lt;&#39;b&gt; -&gt; Gen&lt;&#39;b list&gt;<br /><em>&lt;summary&gt;
 Generates a list of random length. The maximum length depends on the
 size parameter.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs53">val fromGen : gen:Gen&lt;&#39;Value&gt; -&gt; Arbitrary&lt;&#39;Value&gt;<br /><em>&lt;summary&gt;
 Construct an Arbitrary instance from a generator.
 Shrink is not supported for this type.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs54">module Prop

from FsCheck<br /><em>&lt;summary&gt;
Combinators to build properties, which define the property to be tested, with some
convenience methods to investigate the generated arguments and any found counter-examples.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs55">val forAll : arb:Arbitrary&lt;&#39;Value&gt; -&gt; body:(&#39;Value -&gt; &#39;Testable) -&gt; Property<br /><em>&lt;summary&gt;
Quantified property combinator. Provide a custom test data generator to a property.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs56">type Check =
  static member All : config:Config * test:Type -&gt; unit + 1 overload
  static member Method : config:Config * methodInfo:MethodInfo * ?target:obj -&gt; unit
  static member One : config:Config * property:&#39;Testable -&gt; unit + 1 overload
  static member Quick : property:&#39;Testable -&gt; unit + 1 overload
  static member QuickAll : test:Type -&gt; unit + 1 overload
  static member QuickThrowOnFailure : property:&#39;Testable -&gt; unit
  static member QuickThrowOnFailureAll : test:Type -&gt; unit + 1 overload
  static member Verbose : property:&#39;Testable -&gt; unit + 1 overload
  static member VerboseAll : test:Type -&gt; unit + 1 overload
  static member VerboseThrowOnFailure : property:&#39;Testable -&gt; unit
  ...</div>
<div class="fsdocs-tip" id="fs57">static member Check.Quick : property:&#39;Testable -&gt; unit<br />static member Check.Quick : name:string * property:&#39;Testable -&gt; unit</div>
<div class="fsdocs-tip" id="fs58">namespace FsCheck.Experimental</div>
<div class="fsdocs-tip" id="fs59">val machine : Machine&lt;Sut,State&gt;</div>
<div class="fsdocs-tip" id="fs60">Multiple items<br />type Machine&lt;&#39;Actual,&#39;Model&gt; =
  new : maxNumberOfCommands:int -&gt; Machine&lt;&#39;Actual,&#39;Model&gt; + 1 overload
  abstract member Next : &#39;Model -&gt; Gen&lt;Operation&lt;&#39;Actual,&#39;Model&gt;&gt;
  abstract member ShrinkOperations : Operation&lt;&#39;Actual,&#39;Model&gt; list -&gt; seq&lt;Operation&lt;&#39;Actual,&#39;Model&gt; list&gt; + 1 overload
  member MaxNumberOfCommands : int
  abstract member Setup : Arbitrary&lt;Setup&lt;&#39;Actual,&#39;Model&gt;&gt;
  override TearDown : TearDown&lt;&#39;Actual&gt;
  abstract member TearDown : TearDown&lt;&#39;Actual&gt;<br /><em>&lt;summary&gt;
Defines the initial state for actual and model object, and allows to define the generator to use
for the next state, based on the model.
&lt;/summary&gt;</em><br /><br />--------------------<br />new : unit -&gt; Machine&lt;&#39;Actual,&#39;Model&gt;<br />new : maxNumberOfCommands:int -&gt; Machine&lt;&#39;Actual,&#39;Model&gt;</div>
<div class="fsdocs-tip" id="fs61">Multiple items<br />type Setup&lt;&#39;Actual,&#39;Model&gt; =
  new : unit -&gt; Setup&lt;&#39;Actual,&#39;Model&gt;
  abstract member Actual : unit -&gt; &#39;Actual
  abstract member Model : unit -&gt; &#39;Model
  override ToString : unit -&gt; string<br /><br />--------------------<br />new : unit -&gt; Setup&lt;&#39;Actual,&#39;Model&gt;</div>
<div class="fsdocs-tip" id="fs62">val __ : Machine&lt;Sut,State&gt;</div>
<div class="fsdocs-tip" id="fs63">val __ : Setup&lt;Sut,State&gt;</div>
<div class="fsdocs-tip" id="fs64">abstract member Setup.Model : unit -&gt; &#39;Model</div>
<div class="fsdocs-tip" id="fs65">abstract member Machine.Next : &#39;Model -&gt; Gen&lt;Operation&lt;&#39;Actual,&#39;Model&gt;&gt;</div>
<div class="fsdocs-tip" id="fs66">Multiple items<br />type Operation&lt;&#39;Actual,&#39;Model&gt; =
  interface IOperation
  new : unit -&gt; Operation&lt;&#39;Actual,&#39;Model&gt;
  abstract member Check : &#39;Actual * &#39;Model -&gt; Property
  abstract member Pre : &#39;Model -&gt; bool + 1 overload
  abstract member Run : &#39;Model -&gt; &#39;Model<br /><em>&lt;summary&gt;
An operation describes pre and post conditions and the model for a single operation under test.
The post-conditions are the invariants that will be checked; when these do not hold the test fails.
&lt;/summary&gt;</em><br /><br />--------------------<br />new : unit -&gt; Operation&lt;&#39;Actual,&#39;Model&gt;</div>
<div class="fsdocs-tip" id="fs67">val __ : Operation&lt;Sut,State&gt;</div>
<div class="fsdocs-tip" id="fs68">abstract member Operation.Check : &#39;Actual * &#39;Model -&gt; Property</div>
<div class="fsdocs-tip" id="fs69">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><em>&lt;summary&gt;Print to a string using the given format.&lt;/summary&gt;<br />&lt;param name=&quot;format&quot;&gt;The formatter.&lt;/param&gt;<br />&lt;returns&gt;The formatted result.&lt;/returns&gt;</em></div>
<div class="fsdocs-tip" id="fs70">System.Object.ToString() : string</div>
<div class="fsdocs-tip" id="fs71">module StateMachine

from FsCheck.Experimental</div>
<div class="fsdocs-tip" id="fs72">val toProperty : spec:Machine&lt;&#39;Actual,&#39;Model&gt; -&gt; Property<br /><em>&lt;summary&gt;
Turn a machine specification into a property.
&lt;/summary&gt;</em></div>
